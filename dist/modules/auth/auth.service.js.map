{"version":3,"file":"auth.service.js","sourceRoot":"","sources":["../../../src/modules/auth/auth.service.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,2CAAiE;AACjE,uDAAmD;AACnD,0DAAyD;AAKzD,iCAAiC;AAEjC,0DAAsD;AAI/C,IAAM,WAAW,GAAjB,MAAM,WAAW;IACtB,YACmB,WAAwB,EACxB,YAA0B;QAD1B,gBAAW,GAAX,WAAW,CAAa;QACxB,iBAAY,GAAZ,YAAY,CAAc;IAC1C,CAAC;IAGJ,KAAK,CAAC,aAAa,CAAC,GAAkB;QACpC,IAAI,CAAC;YAEH,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,eAAe,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;YAEpE,IAAI,SAAS;gBAAE,MAAM,IAAI,4BAAmB,CAAC,iBAAQ,CAAC,UAAU,CAAC,CAAC;YAGlE,MAAM,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;YACvC,OAAO,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QAChD,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,MAAM,IAAI,4BAAmB,CAAC,iBAAQ,CAAC,UAAU,CAAC,CAAC;QACrD,CAAC;IACH,CAAC;IAKD,KAAK,CAAC,SAAS,CAAC,GAAiB;QAC/B,IAAI,CAAC;YAEH,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,eAAe,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;YAIpE,IAAI,CAAC,SAAS;gBAAE,MAAM,IAAI,4BAAmB,CAAC,iBAAQ,CAAC,cAAc,CAAC,CAAC;YAIvE,MAAM,gBAAgB,GAAG,MAAM,MAAM,CAAC,OAAO,CAC3C,GAAG,CAAC,QAAQ,EACZ,SAAS,CAAC,QAAQ,CACnB,CAAC;YAGF,IAAI,CAAC,gBAAgB;gBAAE,MAAM,IAAI,4BAAmB,CAAC,iBAAQ,CAAC,UAAU,CAAC,CAAC;YAU1E,OAAO,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QAChD,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,MAAM,IAAI,KAAK,CAAC,KAAK,CAAC,CAAC;QACzB,CAAC;IACH,CAAC;CAGF,CAAA;AA3DY,kCAAW;sBAAX,WAAW;IADvB,IAAA,mBAAU,GAAE;qCAGqB,0BAAW;QACV,4BAAY;GAHlC,WAAW,CA2DvB","sourcesContent":["import { BadRequestException, Injectable } from \"@nestjs/common\";\nimport { UserService } from \"../user/user.service\";\nimport { AppError } from \"../../common/constants/errors\";\n\nimport { CreateUserDTO } from \"../user/dto\";\nimport { UserLoginDTO } from \"./dto\";\n\nimport * as bcrypt from \"bcrypt\";\n\nimport { TokenService } from \"../token/token.service\";\nimport { AuthUserResponse } from \"./response\";\n\n@Injectable()\nexport class AuthService {\n  constructor(\n    private readonly userService: UserService,\n    private readonly tokenService: TokenService,\n  ) {}\n\n  //registration user\n  async registerUsers(dto: CreateUserDTO): Promise<AuthUserResponse> {\n    try {\n      //if has user\n      const existUser = await this.userService.findUserByEmail(dto.email);\n\n      if (existUser) throw new BadRequestException(AppError.USER_EXIST);\n      //if  has user  end --\n\n      await this.userService.createUser(dto);\n      return this.userService.publicUser(dto.email);\n    } catch (error) {\n      throw new BadRequestException(AppError.USER_EXIST);\n    }\n  }\n\n  //registration user end---------------------\n\n  //login user\n  async loginUser(dto: UserLoginDTO): Promise<AuthUserResponse> {\n    try {\n      //find user by email in DB\n      const existUser = await this.userService.findUserByEmail(dto.email);\n      //find user by email in DB end--\n\n      // has user or not if not has error\n      if (!existUser) throw new BadRequestException(AppError.USER_NOT_EXIST);\n      // has user or not if not has error end--\n\n      //verification re hash password\n      const validatePassword = await bcrypt.compare(\n        dto.password,\n        existUser.password,\n      );\n\n      // if password is error\n      if (!validatePassword) throw new BadRequestException(AppError.WRONG_DATA);\n      // if password is error end --\n\n      //const userData = {\n      //  name: existUser.firstName,\n      //  email: existUser.email,\n      //};\n\n      //verification re hash password end ---\n\n      return this.userService.publicUser(dto.email);\n    } catch (error) {\n      throw new Error(error);\n    }\n  }\n\n  //login user end-----------------------\n}\n"]}